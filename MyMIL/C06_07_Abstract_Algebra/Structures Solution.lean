import Mathlib.Tactic

noncomputable section

namespace C06

section structure_point

@[ext]
structure Point where
  x : ‚Ñù
  y : ‚Ñù
  z : ‚Ñù

#check Point.ext

example (a b : Point) (hx : a.x = b.x) (hy : a.y = b.y) (hz : a.z = b.z) : a = b := by
  ext
  repeat' assumption

def myPoint1 : Point where
  x := 2
  y := - 1
  z := 4

def myPoint2 : Point :=
  ‚ü®2, - 1, 4‚ü©

def myPoint3 :=
  Point.mk 2 (- 1) 4

structure Point' where build ::
  x : ‚Ñù
  y : ‚Ñù
  z : ‚Ñù

#check Point'.build

#check Point'.build 2 (- 1) 4

namespace Point

def add (a b : Point) : Point :=
  ‚ü®a.x + b.x, a.y + b.y, a.z + b.z‚ü©

def add' (a b : Point) : Point where
  x := a.x + b.x
  y := a.y + b.y
  z := a.z + b.z

#check add myPoint1 myPoint2
#check myPoint1.add myPoint2

end Point

#check Point.add myPoint1 myPoint2
#check myPoint1.add myPoint2

namespace Point

protected theorem add_comm (a b : Point) : add a b = add b a := by
  rw [add, add]
  ext <;> dsimp
  repeat' apply add_comm

example (a b : Point) : add a b = add b a := by
  simp only [add, add_comm]

theorem add_x (a b : Point) : (a.add b).x = a.x + b.x :=
  rfl

protected theorem add_assoc (a b c : Point) : (a.add b).add c = a.add (b.add c) := by
  simp only [add, add_assoc]

def smul (r : ‚Ñù) (a : Point) : Point :=
  ‚ü®r * a.x, r * a.y, r * a.z‚ü©

theorem smul_distrib (r : ‚Ñù) (a b : Point) :
    (smul r a).add (smul r b) = smul r (a.add b) := by
  simp only [add, smul, mul_add]

end Point

def Point'' :=
  ‚Ñù √ó ‚Ñù √ó ‚Ñù

variable {a : Point''}

#check a.1

--#check a.3

#check a.2.1



def PReal :=
  { x : ‚Ñù // 0 < x }

variable (x : PReal)

#check x.val

#check x.property

#check x.1

#check x.2

end structure_point



section structure_group

structure AddGroup‚ÇÄ (Œ± : Type*) where
  add : Œ± ‚Üí Œ± ‚Üí Œ±
  zero : Œ±
  neg : Œ± ‚Üí Œ±
  add_assoc : ‚àÄ x y z : Œ±, add (add x y) z = add x (add y z)
  add_zero : ‚àÄ x : Œ±, add x zero = x
  zero_add : ‚àÄ x : Œ±, add zero x = x
  add_left_neg : ‚àÄ x : Œ±, add (neg x) x = zero

namespace Point

def neg (a : Point) : Point := ‚ü®- a.x, - a.y, - a.z‚ü©

def zero : Point := ‚ü®0, 0, 0‚ü©

def addGroupPoint : AddGroup‚ÇÄ Point where
  add := add
  zero := zero
  neg := neg
  add_assoc := by
    simp only [add, add_assoc, implies_true]
  add_zero := by
    simp only [add, zero, add_zero, implies_true]
  zero_add := by
    simp only [add, zero, zero_add, implies_true]
  add_left_neg := by
    simp only [add, neg, add_left_neg, zero, implies_true]

end Point

structure Group‚ÇÄ (Œ± : Type*) where
  mul : Œ± ‚Üí Œ± ‚Üí Œ±
  one : Œ±
  inv : Œ± ‚Üí Œ±
  mul_assoc : ‚àÄ x y z : Œ±, mul (mul x y) z = mul x (mul y z)
  mul_one : ‚àÄ x : Œ±, mul x one = x
  one_mul : ‚àÄ x : Œ±, mul one x = x
  mul_left_inv : ‚àÄ x : Œ±, mul (inv x) x = one

end structure_group


section class_group

class AddGroup‚ÇÇ (Œ± : Type*) where
  add : Œ± ‚Üí Œ± ‚Üí Œ±
  zero : Œ±
  neg : Œ± ‚Üí Œ±
  add_assoc : ‚àÄ x y z : Œ±, add (add x y) z = add x (add y z)
  add_zero : ‚àÄ x : Œ±, add x zero = x
  zero_add : ‚àÄ x : Œ±, add zero x = x
  add_left_neg : ‚àÄ x : Œ±, add (neg x) x = zero

open AddGroup‚ÇÇ

theorem add_right_neg {Œ± : Type*} [AddGroup‚ÇÇ Œ±] (x : Œ±) : add x (neg x) = zero := by
  calc
    _ = add (neg (add x (neg x))) (add (add x (neg x)) (add x (neg x))) := by
      rw [‚Üê AddGroup‚ÇÇ.add_assoc, AddGroup‚ÇÇ.add_left_neg, AddGroup‚ÇÇ.zero_add]
    _ = _ := by
      nth_rw 2 [‚Üê AddGroup‚ÇÇ.add_assoc, AddGroup‚ÇÇ.add_assoc]
      rw [AddGroup‚ÇÇ.add_left_neg, AddGroup‚ÇÇ.add_zero, AddGroup‚ÇÇ.add_left_neg]

namespace Point

instance addGroupPoint' : AddGroup‚ÇÇ Point where
  add := add
  zero := zero
  neg := neg
  add_assoc := by
    simp only [add, add_assoc, implies_true]
  add_zero := by
    simp only [add, zero, add_zero, implies_true]
  zero_add := by
    simp only [add, zero, zero_add, implies_true]
  add_left_neg := by
    simp only [add, neg, add_left_neg, zero, implies_true]

theorem add_right_neg (x : Point) : add x (neg x) = zero :=
  C06.add_right_neg x

variable (a b : Point)

instance instAdd : Add Point where
  add a b := add a b

#check a + b

end Point

end class_group



section hierachies

-- only for notation
class One‚ÇÅ (Œ± : Type) where
  /-- The element one -/
  one : Œ±

#check One‚ÇÅ.one -- One‚ÇÅ.one {Œ± : Type} [self : One‚ÇÅ Œ±] : Œ±

example (Œ± : Type) [One‚ÇÅ Œ±] : Œ± := One‚ÇÅ.one

example (Œ± : Type) [One‚ÇÅ Œ±] := (One‚ÇÅ.one : Œ±)

@[inherit_doc]
notation "ùüô" => One‚ÇÅ.one

example {Œ± : Type} [One‚ÇÅ Œ±] : Œ± := ùüô

example {Œ± : Type} [One‚ÇÅ Œ±] : (ùüô : Œ±) = ùüô := rfl


class Dia‚ÇÅ (Œ± : Type) where
  dia : Œ± ‚Üí Œ± ‚Üí Œ±

infixl:70 " ‚ãÑ "   => Dia‚ÇÅ.dia


class Semigroup‚ÇÇ (Œ± : Type) where
  toDia‚ÇÅ : Dia‚ÇÅ Œ±
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)

variable {a : Type*} [Semigroup‚ÇÇ Œ±] (a b : Œ±)

--#check a ‚ãÑ b

attribute [instance] Semigroup‚ÇÇ.toDia‚ÇÅ

#check a ‚ãÑ b

example {Œ± : Type} [Semigroup‚ÇÇ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b


class Semigroup‚ÇÅ (Œ± : Type) extends Dia‚ÇÅ Œ± where
  /-- Diamond is associative -/
  dia_assoc : ‚àÄ a b c : Œ±, a ‚ãÑ b ‚ãÑ c = a ‚ãÑ (b ‚ãÑ c)

example {Œ± : Type} [Semigroup‚ÇÅ Œ±] (a b : Œ±) : Œ± := a ‚ãÑ b

class DiaOneClass‚ÇÅ (Œ± : Type) extends One‚ÇÅ Œ±, Dia‚ÇÅ Œ± where
  /-- One is a left neutral element for diamond. -/
  one_dia : ‚àÄ a : Œ±, ùüô ‚ãÑ a = a
  /-- One is a right neutral element for diamond -/
  dia_one : ‚àÄ a : Œ±, a ‚ãÑ ùüô = a


class Monoid‚ÇÅ (Œ± : Type) extends Semigroup‚ÇÅ Œ±, DiaOneClass‚ÇÅ Œ±


class Monoid‚ÇÇ (Œ± : Type) where
  toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±
  toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±


example {Œ± : Type} [Monoid‚ÇÅ Œ±] :
  (Monoid‚ÇÅ.toSemigroup‚ÇÅ.toDia‚ÇÅ.dia : Œ± ‚Üí Œ± ‚Üí Œ±) = Monoid‚ÇÅ.toDiaOneClass‚ÇÅ.toDia‚ÇÅ.dia := rfl


/- Monoid‚ÇÇ.mk {Œ± : Type} (toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±) (toDiaOneClass‚ÇÅ : DiaOneClass‚ÇÅ Œ±) : Monoid‚ÇÇ Œ± -/
#check Monoid‚ÇÇ.mk

/- Monoid‚ÇÅ.mk {Œ± : Type} [toSemigroup‚ÇÅ : Semigroup‚ÇÅ Œ±] [toOne‚ÇÅ : One‚ÇÅ Œ±] (one_dia : ‚àÄ (a : Œ±), ùüô ‚ãÑ a = a) (dia_one : ‚àÄ (a : Œ±), a ‚ãÑ ùüô = a) : Monoid‚ÇÅ Œ± -/
#check Monoid‚ÇÅ.mk


#check Monoid‚ÇÅ.toSemigroup‚ÇÅ
#check Monoid‚ÇÅ.toDiaOneClass‚ÇÅ


class Inv‚ÇÅ (Œ± : Type) where
  /-- The inversion function -/
  inv : Œ± ‚Üí Œ±

@[inherit_doc]
postfix:max "‚Åª¬π" => Inv‚ÇÅ.inv

class Group‚ÇÅ (G : Type) extends Monoid‚ÇÅ G, Inv‚ÇÅ G where
  inv_dia : ‚àÄ a : G, a‚Åª¬π ‚ãÑ a = ùüô


lemma left_inv_eq_right_inv‚ÇÅ {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê DiaOneClass‚ÇÅ.one_dia c, ‚Üê hba, Semigroup‚ÇÅ.dia_assoc, hac, DiaOneClass‚ÇÅ.dia_one b]

open DiaOneClass‚ÇÅ Semigroup‚ÇÅ Group‚ÇÅ

example {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚ãÑ a = ùüô) (hac : a ‚ãÑ c = ùüô) : b = c := by
  rw [‚Üê one_dia c, ‚Üê hba, dia_assoc, hac, dia_one b]


lemma inv_eq_of_dia [Group‚ÇÅ G] {a b : G} (h : a ‚ãÑ b = ùüô) : a‚Åª¬π = b :=
  left_inv_eq_right_inv‚ÇÅ (inv_dia a) h

lemma dia_inv [Group‚ÇÅ G] (a : G) : a ‚ãÑ a‚Åª¬π = ùüô := by
  rw [‚Üê inv_dia a‚Åª¬π, inv_eq_of_dia (inv_dia a)]

class AddSemigroup‚ÇÉ (Œ± : Type) extends Add Œ± where
/-- Addition is associative -/
  add_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a + b + c = a + (b + c)

@[to_additive AddSemigroup‚ÇÉ]
class Semigroup‚ÇÉ (Œ± : Type) extends Mul Œ± where
/-- Multiplication is associative -/
  mul_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a * b * c = a * (b * c)

class AddMonoid‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ±, AddZeroClass Œ±

@[to_additive AddMonoid‚ÇÉ]
class Monoid‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ±, MulOneClass Œ±

attribute [to_additive existing] Monoid‚ÇÉ.toMulOneClass

export Semigroup‚ÇÉ (mul_assoc‚ÇÉ)
export AddSemigroup‚ÇÉ (add_assoc‚ÇÉ)

@[to_additive]
lemma left_inv_eq_right_inv' {M : Type} [Monoid‚ÇÉ M] {a b c : M} (hba : b * a = 1) (hac : a * c = 1) : b = c := by
  rw [‚Üê one_mul c, ‚Üê hba, mul_assoc‚ÇÉ, hac, mul_one b]

#check left_neg_eq_right_neg'

class AddCommSemigroup‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ± where
  add_comm : ‚àÄ a b : Œ±, a + b = b + a

@[to_additive AddCommSemigroup‚ÇÉ]
class CommSemigroup‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ± where
  mul_comm : ‚àÄ a b : Œ±, a * b = b * a

class AddCommMonoid‚ÇÉ (Œ± : Type) extends AddMonoid‚ÇÉ Œ±, AddCommSemigroup‚ÇÉ Œ±

@[to_additive AddCommMonoid‚ÇÉ]
class CommMonoid‚ÇÉ (Œ± : Type) extends Monoid‚ÇÉ Œ±, CommSemigroup‚ÇÉ Œ±

class AddGroup‚ÇÉ (G : Type) extends AddMonoid‚ÇÉ G, Neg G where
  neg_add : ‚àÄ a : G, -a + a = 0

@[to_additive AddGroup‚ÇÉ]
class Group‚ÇÉ (G : Type) extends Monoid‚ÇÉ G, Inv G where
  inv_mul : ‚àÄ a : G, a‚Åª¬π * a = 1


attribute [simp] Group‚ÇÉ.inv_mul AddGroup‚ÇÉ.neg_add

open Group‚ÇÉ

@[to_additive]
lemma inv_eq_of_mul [Group‚ÇÉ G] {a b : G} (h : a * b = 1) : a‚Åª¬π = b :=
  left_inv_eq_right_inv' (Group‚ÇÉ.inv_mul a) h

@[to_additive (attr := simp)]
lemma Group‚ÇÉ.mul_inv {G : Type} [Group‚ÇÉ G] {a : G} : a * a‚Åª¬π = 1 := by
  rw [‚Üê inv_mul a‚Åª¬π, inv_eq_of_mul (inv_mul a)]

@[to_additive]
lemma mul_left_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : a * b = a * c) : b = c := by
  rw [‚Üê one_mul b, ‚Üê one_mul c, ‚Üê inv_mul a, mul_assoc‚ÇÉ, h, ‚Üê mul_assoc‚ÇÉ]

@[to_additive]
lemma mul_right_cancel‚ÇÉ {G : Type} [Group‚ÇÉ G] {a b c : G} (h : b * a = c * a) : b = c := by
  rw [‚Üê mul_one b, ‚Üê mul_one c, ‚Üê @mul_inv _ _ a, ‚Üê mul_assoc‚ÇÉ, h, mul_assoc‚ÇÉ]

class AddCommGroup‚ÇÉ (G : Type) extends AddGroup‚ÇÉ G, AddCommMonoid‚ÇÉ G

@[to_additive AddCommGroup‚ÇÉ]
class CommGroup‚ÇÉ (G : Type) extends Group‚ÇÉ G, CommMonoid‚ÇÉ G

end hierachies



section subgroup

#check Subgroup
-- https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Subgroup/Basic.html#Subgroup

#check Subgroup.ext

variable (G : Type*) [Group G] (H : Subgroup G) (K : Subgroup G)

-- The subgroup `H` is contained in the subgroup `K`.
#check H ‚â§ K

-- The intersection of two subgroups.
#check H ‚äì K

example (G : Type*) [Group G] (H : Subgroup G) (K : Subgroup G) : H ‚äì K = H ‚Üî H ‚â§ K := by
  --exact inf_eq_left
  constructor
  ¬∑ intro h g hg
    rw [‚Üê h] at hg
    have : H ‚äì K ‚â§ K := by exact inf_le_right
    exact this hg
  ¬∑ intro h
    ext g
    constructor
    ¬∑ intro hg
      have : H ‚äì K ‚â§ H := by exact inf_le_left
      exact this hg
    ¬∑ intro hg
      have : g ‚àà K := h hg
      exact ‚ü®hg, this‚ü©

variable (G : Type*) [Group G] {H : Subgroup G} (K : Subgroup H)

/-- If `H` is a subgroup of `G` and `K` is a subgroup of `H`, then `K` can be viewed as a subgroup
of `G`. -/
def Subgroup.to_subgroup : Subgroup G where
  carrier := { g : G | ‚àÉ x : K, g = x.1.1 }
  mul_mem' := by
    intro _ _ ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©
    rw [hx, hy]
    exact ‚ü®x * y, rfl‚ü©
  one_mem' := ‚ü®1 , rfl‚ü©
  inv_mem' := by
    intro _ ‚ü®x, hx‚ü©
    rw [hx]
    exact ‚ü®x‚Åª¬π, rfl‚ü©

theorem Subgroup.to_subgroup_le : to_subgroup G K ‚â§ H := by
  intro g ‚ü®x ,hx‚ü©
  rw [hx]
  exact x.1.2

#check Subtype.val_inj

theorem Subgroup.to_subgroup_mem (g : H) : g.1 ‚àà to_subgroup G K ‚Üî g ‚àà K := by
  constructor
  ¬∑ intro ‚ü®x, hx‚ü©
    rw [Subtype.val_inj.mp hx]
    exact x.2
  ¬∑ intro hg
    exact ‚ü®‚ü®g, hg‚ü©, rfl‚ü©

end subgroup



section examples

-- Let `G` be the set of pairs of real numbers `(x, y)`with `x ‚â† 0`. Define the multiplication on `G` by `(x, y)(z, w) = (xz, xw + y)`. Prove that `G` is a group.

@[ext]
structure G where
  x : ‚Ñù
  y : ‚Ñù
  h : x ‚â† 0

instance : Group G where
  mul a b := ‚ü®a.x * b.x, a.x * b.y + a.y, mul_ne_zero a.h b.h‚ü©
  mul_assoc := by
    intro a b c
    /- a = (x‚ÇÅ, y‚ÇÅ), b = (x‚ÇÇ, y‚ÇÇ), c = (x‚ÇÉ, y‚ÇÉ), a * b = (x‚ÇÅ * x‚ÇÇ, x‚ÇÅ * y‚ÇÇ + y‚ÇÅ),
      (a * b) * c = ((x‚ÇÅ * x‚ÇÇ) * x‚ÇÉ, (x‚ÇÅ * x‚ÇÇ) * y‚ÇÉ + (x‚ÇÅ * y‚ÇÇ + y‚ÇÅ))
      b * c = (x‚ÇÇ * x‚ÇÉ, x‚ÇÇ * y‚ÇÉ + x‚ÇÇ)
      a * (b * c) = (x‚ÇÅ * (x‚ÇÇ * x‚ÇÉ), x‚ÇÅ * (x‚ÇÇ * y‚ÇÉ + x‚ÇÇ) + y‚ÇÅ) -/
    ext
    ¬∑ exact mul_assoc a.x b.x c.x
    ¬∑ show (a.x * b.x) * c.y + (a.x * b.y + a.y) = a.x * (b.x * c.y + b.y) + a.y
      ring
  one := ‚ü®1, 0, one_ne_zero‚ü©
  one_mul := by
    intro a
    ext
    ¬∑ exact one_mul a.x
    ¬∑ show 1 * a.y + 0 = a.y
      simp only [one_mul, add_zero]
  mul_one := by
    intro a
    ext
    ¬∑ exact mul_one a.x
    ¬∑ show a.x * 0 + a.y = a.y
      simp only [mul_zero, zero_add]
  inv a := ‚ü®a.x‚Åª¬π, - a.x‚Åª¬π * a.y, inv_ne_zero a.h‚ü©
  mul_left_inv := by
    intro a
    ext
    ¬∑ exact inv_mul_cancel a.h
    ¬∑ show a.x‚Åª¬π * a.y + (- a.x‚Åª¬π * a.y) = 0
      simp only [neg_mul, _root_.add_right_neg]

-- Let `G` be a abelian group, then `{x : G | ‚àÉ n ‚àà ‚Ñï, x ^ n = e}` is a subgroup of `G`.
def fin_order {G : Type*} [CommGroup G] : Subgroup G where
  carrier := { x : G | ‚àÉ n : ‚Ñï, x ^ n = 1 }
  one_mem' := ‚ü®0, pow_zero 1‚ü©
  mul_mem' := by
    intro x y ‚ü®m, hx‚ü© ‚ü®n, hy‚ü©
    use m * n
    calc
      _ = ((x ^ m) ^ n) * ((y ^ n) ^ m) := by
        rw [mul_pow x y (m * n), Nat.mul_comm m n]
        group
      _ = _ := by
        simp only [hx, hy, one_pow, mul_one]
  inv_mem' := by
    intro x ‚ü®m, hx‚ü©
    use m
    rw [inv_pow x m, hx, inv_one]



-- Every cyclic group is a abelian group.
instance {G : Type*} [Group G] (h : IsCyclic G) : CommGroup G := by
  apply CommGroup.mk
  intro a b
  rcases h with ‚ü®g, hg‚ü©
  rcases hg a with ‚ü®m,ha‚ü©
  rcases hg b with ‚ü®n,hb‚ü©
  rw [‚Üê ha, ‚Üê hb, ‚Üê zpow_add, ‚Üê zpow_add, add_comm]


end examples

end C06
